# -*- python -*-
import os.path
import identifier
import string
from typeinfo import GetTypeInformation, VoidType, ternary
from omniidl import idlast, idlvisitor, idlutil, idltype, output

# For compatibility with older Pythons...
def zip(a1, a2):
    l = min(len(a1), len(a2))
    az = []
    for i in range(0, l):
        az.append((a1[i], a2[i]))
    return az

class CGRSWalker(idlvisitor.AstVisitor):
    """Walks over the AST once and writes the CGRS code in the process"""

    def visitAST(self, node):
        """Visit the top-level AST"""
        self.outputInNamespaces = []
        self.inputInNamespaces = ['CDA', 'CGRS']

        self.cxx.out('// This file is automatically generated; do not edit.')
        self.module = node.filebase
        self.cxx.out('#include <exception>')
        self.cxx.out('#include "Utilities.hxx"')
        self.cxx.out('#include "IfaceCGRS.hxx"')
        self.cxx.out('#include "CGRSImplementation.hpp"')
        self.cxx.out('#include "CGRSBootstrap.hpp"')
        self.cxx.out('#include "Iface' + self.module + '.hxx"')

        for [k, v] in self.specialIncludes:
            if k == self.module:
                self.cxx.out('#include "%s"' % v)

        for n in node.declarations():
            n.accept(self)

        self.leaveAllNamespaces()

        self.cxx.out('void init_cgrsmodule_%s()' % self.module)
        self.cxx.out('{')
        self.cxx.inc_indent()
        self.cxx.out('ObjRef<CDA_GenericsService> cgs = CreateGenericsServiceInternal();')
        allMods = []
        newMods = filter(lambda x: isinstance(x, idlast.Module), node.declarations())
        allMods = allMods + newMods
        while newMods != []:
            newMods = reduce(lambda x, y: x + y, \
                               map(lambda x: filter(lambda y: (isinstance(y, idlast.Module)), \
                                                    x.definitions()), newMods), [])
            allMods = allMods + newMods
        allMods = filter(lambda x: x.mainFile(), allMods)

        allIfaces = reduce(lambda x, y: x + y, \
                           map(lambda x: filter(lambda y: isinstance(y, idlast.Interface), x.definitions()), \
                               allMods), [])
        allIfaceNames = map(lambda x: x.corbacxxscoped, allIfaces)
        for n in allIfaces:
            self.cxx.out('{')
            self.cxx.inc_indent()
            self.cxx.out('RETURN_INTO_OBJREF(iftmp, CDA::CGRS::%s, new CDA::CGRS::%s());' % (n.corbacxxscoped, n.corbacxxscoped))
            self.cxx.out('cgs->registerInterface("%s", iftmp);' % n.corbacxxscoped)
            self.cxx.dec_indent()
            self.cxx.out('}')
        for n in self.bootstrapSpecials:
            if n[0] in allIfaceNames:
                self.cxx.out('{')
                self.cxx.inc_indent()
                self.cxx.out('ObjRef<iface::%s> bstmp = %s();' % (n[0], n[1]))
                self.cxx.out('ObjRef<iface::CGRS::GenericValue> objtmp = cgs->makeObject(bstmp);')
                self.cxx.out('cgs->registerBootstrap("%s", objtmp);' % n[1])
                self.cxx.dec_indent()
                self.cxx.out('}')

        allEnums = reduce(lambda x, y: x + y, \
                           map(lambda x: filter(lambda y: isinstance(y, idlast.Enum), x.definitions()), \
                               allMods) +\
                           map(lambda x: filter(lambda y: isinstance(y, idlast.Enum), x.declarations()), \
                               allIfaces), [])
        for n in allEnums:
            self.cxx.out('{')
            self.cxx.inc_indent()
            self.cxx.out('RETURN_INTO_OBJREF(typ, CDA::CGRS::%s, new CDA::CGRS::%s());' %\
                         (n.corbacxxscoped, n.corbacxxscoped))
            self.cxx.out('cgs->registerType(typ);')
            self.cxx.dec_indent()
            self.cxx.out('}')

        self.cxx.dec_indent()
        self.cxx.out('}')

    def visitModule(self, node):
        """Visit all the definitions in a module."""
        self.inputInNamespaces.append(node.simplename)
        for n in node.definitions():
            if n.mainFile():
                n.accept(self)
        self.inputInNamespaces.pop()

    def enterAllNamespaces(self):
        if self.inputInNamespaces == self.outputInNamespaces:
            return
        try:
            keepDepth = map(lambda (a, b): a != b, zip(self.inputInNamespaces, self.outputInNamespaces)).index(1)
        except ValueError:
            keepDepth = min(len(self.inputInNamespaces), len(self.outputInNamespaces))

        for i in range (0, len(self.outputInNamespaces) - keepDepth):
            self.cxx.dec_indent()
            self.cxx.out('};')
        for ns in self.inputInNamespaces[keepDepth:]:
            self.cxx.out('namespace %s' % ns)
            self.cxx.out('{')
            self.cxx.inc_indent()
        self.outputInNamespaces = self.inputInNamespaces

    def leaveAllNamespaces(self):
        for i in self.outputInNamespaces:
            self.cxx.dec_indent()
            self.cxx.out('};')
        self.outputInNamespaces = []

    def visitForward(self, node):
        pass

    def recursivelyFindAncestralBases(self, node):
        ret = []
        for inh in node.inherits():
            # It seems inherits can return other things...
            if isinstance(inh, idlast.Interface):
                ret.append(inh)
                ret = ret + self.recursivelyFindAncestralBases(inh)
        return ret

    def visitInterface(self, node):
        self.iface = node.corbacxxscoped

        self.enterAllNamespaces()

        hasCallback = 0
        for p in node.pragmas(): hasCallback = hasCallback or (p.text() == "user-callback")

        if hasCallback:
            self.cxx.out('class Callback%s' % node.simplename)
            self.cxx.out('  : public %s, public CGRSCallback' % node.simplecxxscoped)
            self.cxx.out('{')
            self.cxx.out('public:')
            self.cxx.inc_indent()
            self.cxx.out('Callback%s(iface::CGRS::CallbackObjectValue* aValue)' % node.simplename)
            self.cxx.out('  : mValue(aValue)')
            self.cxx.out('{')
            self.cxx.out('}')
            self.cxx.out('already_AddRefd<iface::CGRS::CallbackObjectValue> unwrap() { mValue->add_ref(); return mValue.getPointer(); }')
            self.generateCallbackFunctions(node, {})
            self.cxx.dec_indent()
            self.cxx.out('private:')
            self.cxx.inc_indent()
            self.cxx.out('ObjRef<iface::CGRS::CallbackObjectValue> mValue;')
            self.cxx.dec_indent()
            self.cxx.out('};')

        self.cxx.out('class %s' % node.simplename)
        self.cxx.out('  : public CDA_GenericInterfaceBase')
        self.cxx.out('{')
        self.cxx.out('public:')
        self.cxx.inc_indent()
        self.cxx.out('%s() {}' % node.simplename)
        self.cxx.out('~%s() {}' % node.simplename)
        self.cxx.out('CDA_IMPL_ID;')
        self.cxx.out('CDA_IMPL_REFCOUNT;')
        self.cxx.out('CDA_IMPL_QI1(CGRS::GenericInterface);')

        bases = self.recursivelyFindAncestralBases(node)
        self.cxx.out('int32_t baseCount() throw() { return %d; }' % len(bases))
        self.cxx.out('already_AddRefd<iface::CGRS::GenericInterface> getBase(int32_t aBaseName)')
        self.cxx.out('  throw(std::exception&)')
        self.cxx.out('{')
        self.cxx.inc_indent()
        self.cxx.out('ObjRef<CDA_GenericsService> cgs = CreateGenericsServiceInternal();')
        self.cxx.out('switch (aBaseName) {')
        self.cxx.inc_indent()
        for (i, b) in zip(range(0,len(bases)), bases):
            self.cxx.out('case %d: return cgs->getInterfaceByName("%s");' % (i, b.simplecxxscoped))
        self.cxx.out('default: throw iface::CGRS::CGRSError();')
        self.cxx.dec_indent()
        self.cxx.out('}') # Close switch
        self.cxx.dec_indent()
        self.cxx.out('}') # Close getBase()

        # Do nested enums before we declare remainder private:
        for n in node.contents():
            if isinstance(n, idlast.Enum):
                n.accept(self)

        # Now define classes (within this class) for attributes and operations...
        self.cxx.dec_indent()
        self.cxx.out('private:')
        self.cxx.inc_indent()

        self.supportedAttributes = []
        self.supportedOperations = []
        for n in node.contents():
            if isinstance(n, idlast.Attribute) or isinstance(n, idlast.Operation):
                n.accept(self)

        self.cxx.dec_indent()
        self.cxx.out('public:')
        self.cxx.inc_indent()

        self.cxx.out('int32_t attributeCount() throw(std::exception&) { return %d; }' % len(self.supportedAttributes))
        self.cxx.out('int32_t operationCount() throw(std::exception&) { return %d; }' % len(self.supportedOperations))

        self.cxx.out('already_AddRefd<iface::CGRS::GenericAttribute>')
        self.cxx.out('getAttributeByIndex(int32_t aAttributeNumber) throw(std::exception&)')
        self.cxx.out('{')
        self.cxx.inc_indent()
        self.cxx.out('switch (aAttributeNumber)')
        self.cxx.out('{')
        self.cxx.inc_indent()
        for (i, b) in zip(range(0,len(self.supportedAttributes)), self.supportedAttributes):
            self.cxx.out('case %d: return new CDA::CGRS::%s::attr%s();' % (i, node.corbacxxscoped, b))
        self.cxx.out('default: throw iface::CGRS::CGRSError();')
        self.cxx.dec_indent()
        self.cxx.out('}')
        self.cxx.dec_indent()
        self.cxx.out('}')

        self.cxx.out('already_AddRefd<iface::CGRS::GenericMethod>')
        self.cxx.out('getOperationByIndex(int32_t aOperationNumber) throw(std::exception&)')
        self.cxx.out('{')
        self.cxx.inc_indent()
        self.cxx.out('switch (aOperationNumber)')
        self.cxx.out('{')
        self.cxx.inc_indent()
        for (i, b) in zip(range(0,len(self.supportedOperations)), self.supportedOperations):
            self.cxx.out('case %d: return new CDA::CGRS::%s::meth%s();' % (i, node.corbacxxscoped, b))
        self.cxx.out('default: throw iface::CGRS::CGRSError();')
        self.cxx.dec_indent()
        self.cxx.out('}')
        self.cxx.dec_indent()
        self.cxx.out('}')

        self.cxx.out('already_AddRefd<iface::CGRS::GenericAttribute>')
        self.cxx.out('getAttributeByName(const std::string& aAttributeName) throw(std::exception&)')
        self.cxx.out('{')
        self.cxx.inc_indent()
        elseV = ''
        for b in self.supportedAttributes:
            self.cxx.out('%sif (aAttributeName == "%s") return new CDA::CGRS::%s::attr%s();' % (elseV, b, node.corbacxxscoped, b))
            elseV = 'else '
        self.cxx.out('throw iface::CGRS::CGRSError();')
        self.cxx.dec_indent()
        self.cxx.out('}')

        self.cxx.out('already_AddRefd<iface::CGRS::GenericMethod>')
        self.cxx.out('getOperationByName(const std::string& aOperationName) throw(std::exception&)')
        self.cxx.out('{')
        self.cxx.inc_indent()
        elseV = ''
        for b in self.supportedOperations:
            self.cxx.out('%sif (aOperationName == "%s") return new CDA::CGRS::%s::meth%s();' % (elseV, b, node.corbacxxscoped, b))
            elseV = 'else '
        self.cxx.out('throw iface::CGRS::CGRSError();')
        self.cxx.dec_indent()
        self.cxx.out('}')

        self.cxx.out('void* makeCallbackProxy(iface::CGRS::CallbackObjectValue* aValue);')

        self.cxx.dec_indent()
        self.cxx.out('};') # Close class

        self.leaveAllNamespaces()
        self.cxx.out('void* CDA::CGRS::%s::makeCallbackProxy(iface::CGRS::CallbackObjectValue* aValue)' % node.corbacxxscoped)
        self.cxx.out('{')
        if hasCallback:
            self.cxx.out('  return reinterpret_cast<void*>(static_cast<%s*>(new Callback%s(aValue)));' %\
                             (node.simplecxxscoped, node.simplename))
        else:
            self.cxx.out('  return NULL;')
        self.cxx.out('}')


    def generateCallbackFunctions(self, node, seen):
        if (seen.has_key(node.simplecxxscoped)): return
        seen[node.simplecxxscoped] = 1
        for d in node.inherits():
            self.generateCallbackFunctions(d, seen)
        blacklist = []
        if node.simplecxxscoped == "iface::XPCOM::IObject":
            self.cxx.out('CDA_IMPL_REFCOUNT;')
            self.cxx.out('CDA_IMPL_ID;')
            self.cxx.out('void* query_interface(const std::string& aTarget) throw()')
            self.cxx.out('{')
            self.cxx.inc_indent()
            # Firstly check with the target...
            self.cxx.out('std::vector<iface::CGRS::GenericValue*> valseq;')
            self.cxx.out('bool wasExcept;')
            self.cxx.out('ObjRef<iface::CGRS::GenericValue> qiRet = ')
            self.cxx.out('  mValue->invokeOnInterface("XPCOM::IObject", "query_interface", valseq, valseq, &wasExcept);')
            self.cxx.out('if (wasExcept) return NULL;')
            self.cxx.out('ObjRef<CDA_GenericsService> cgs = CreateGenericsServiceInternal();')
            self.cxx.out('ObjRef<iface::CGRS::GenericValue> vv = cgs->makeVoid();\n')
            self.cxx.out('if (!CDA_objcmp(vv, qiRet)) return NULL;')
            self.cxx.out('ObjRef<iface::CGRS::GenericInterface> gi = cgs->getInterfaceByName(aTarget);\n')
            self.cxx.out('if (gi == NULL) return NULL;')
            self.cxx.out('return static_cast<CDA_GenericInterfaceBase*>(gi.getPointer())->makeCallbackProxy(mValue);')
            self.cxx.dec_indent()
            self.cxx.out('}')
            blacklist = ['add_ref', 'release_ref', 'query_interface', 'objid']
        for d in node.callables():
            if isinstance(d, idlast.Operation):
                if d.simplename in blacklist: continue
                global dv
                dv = d
                exception = ternary(d.raises() == [], lambda: "std::exception", lambda: dv.raises()[0].simplecxxscoped)
                self.generateCallbackFunction(\
                    node.corbacxxscoped, d.simplename, exception, d.returnType(),\
                    map(lambda x: (x.paramType(), x.is_in(), x.is_out()),\
                            d.parameters()))
            elif isinstance(d, idlast.Attribute):
                for a in d.declarators():
                    if a.simplename in blacklist: continue
                    self.generateCallbackFunction(\
                        node.corbacxxscoped, a.simplename, 'std::exception', d.attrType(), [])
                    if not d.readonly():
                        self.generateCallbackFunction(\
                            node.corbacxxscoped, a.simplename, 'std::exception', None, [(d.attrType(), 1, 0)])

    def generateCallbackFunction(self, ifaceName, name, exception, ret, argInfo):
        global retv # Workaround for Python 1.x
        retv = ret
        rtype = ternary(ret == None, lambda: None, lambda: GetTypeInformation(retv))
        global rtypev
        rtypev = rtype
        rname = ternary(rtype == None, lambda: "void", lambda: rtypev.cppReturnSignatureType)
        argsig = ''
        for (i, (argType, argIn, argOut)) in zip(range(0, len(argInfo)), argInfo):
            argt = GetTypeInformation(argType)
            if argsig != '':
                argsig = argsig + ', '
            global argtv
            argtv = argt
            argsig = '%s%s arg%d' % (argsig, ternary(argOut, lambda: argtv.cppOutSignatureType, lambda: argtv.cppInSignatureType), i)

        self.cxx.out('%s %s(%s)' % (rname, name, argsig))
        self.cxx.out('  throw(std::exception&)')
        self.cxx.out('{')
        self.cxx.inc_indent()

        self.cxx.out('ObjRef<CDA_GenericsService> cgs = CreateGenericsServiceInternal();')
        self.cxx.out('std::vector<iface::CGRS::GenericValue*> inValSeq;')
        self.cxx.out('scoped_destroy<std::vector<iface::CGRS::GenericValue*> > inValSeqReleaser(inValSeq, ' +\
                     'new container_destructor<std::vector<iface::CGRS::GenericValue*> >(new objref_destructor<iface::CGRS::GenericValue>()));')
        for (i, (argType, argIn, argOut)) in zip(range(0, len(argInfo)), argInfo):
            if argIn:
                self.cxx.out('{')
                self.cxx.inc_indent()
                argt = GetTypeInformation(argType)
                # Note: Objects can actually have one of two incompatible interfaces - callback or normal.
                self.cxx.out('iface::%s* genval;' % argt.genericIface)
                self.cxx.out(argt.convertNativeToGeneric('%sarg%d' % (argt.deref(argOut), i), 'genval'))
                self.cxx.out('inValSeq.push_back(genval);')
                self.cxx.dec_indent()
                self.cxx.out('}')
        self.cxx.out('std::vector<iface::CGRS::GenericValue*> outValSeq;')
        self.cxx.out('scoped_destroy<std::vector<iface::CGRS::GenericValue*> > outValSeqReleaser(outValSeq, new container_destructor<std::vector<iface::CGRS::GenericValue*> >(new objref_destructor<iface::CGRS::GenericValue>()));')
        self.cxx.out('bool wasException = false;')
        self.cxx.out('ObjRef<iface::CGRS::GenericValue> genret = mValue->invokeOnInterface("%s", "%s", inValSeq, outValSeq, &wasException);' % (ifaceName, name))
        self.cxx.out('if (wasException) throw %s();' % exception)

        self.cxx.out('std::vector<iface::CGRS::GenericValue*>::iterator outVali = outValSeq.begin();')
        for (i, (argType, argIn, argOut)) in zip(range(0, len(argInfo)), argInfo):
            if argOut:
                argt = GetTypeInformation(argType)
                self.cxx.out('DECLARE_QUERY_INTERFACE_OBJREF(genout%d, (*outVali), %s);' % (i, argt.genericIface))
                self.cxx.out(argt.convertGenericToNative('genout%d' % i, '%sarg%d' % (argt.deref(1), i)))
                self.cxx.out('outVali++;')
        if rtype != None and not isinstance(rtype, VoidType):
            self.cxx.out('DECLARE_QUERY_INTERFACE_OBJREF(genreti, genret, %s);' % rtype.genericIface)
            self.cxx.out(rtype.makeStorage('retval'))
            self.cxx.out(rtype.convertGenericToNative('genreti', 'retval'))
            self.cxx.out(rtype.returnStorage('retval'))
        self.cxx.dec_indent()
        self.cxx.out('}')

    def visitTypedef(self, node):
        pass

    def visitMember(self, node):
        pass

    def visitStruct(self, node):
        raise "Structs are not supported"

    def visitUnion(self, node):
        raise "Unions are not supported"

    def visitEnumerator(self, node):
        pass

    def visitEnum(self, node):
        self.enterAllNamespaces()
        self.cxx.out('class %s' % node.simplename)
        self.cxx.out('  : public iface::CGRS::EnumType')
        self.cxx.out('{')
        self.cxx.out('public:')
        self.cxx.inc_indent()
        self.cxx.out('%s()' % node.simplename)
        self.cxx.out('{')
        self.cxx.inc_indent()
        for n in node.enumerators():
            self.cxx.out('mNameToInt.insert(std::pair<std::string, uint32_t>("%s", %lu));' %\
                             (n.identifier(), n.value()))
            self.cxx.out('mIntToName.insert(std::pair<uint32_t, std::string>(%lu, "%s"));' %\
                             (n.value(), n.identifier()))
        self.cxx.dec_indent()
        self.cxx.out('}')
        self.cxx.out('CDA_IMPL_ID;')
        self.cxx.out('CDA_IMPL_REFCOUNT;')
        self.cxx.out('CDA_IMPL_QI2(CGRS::EnumType, CGRS::GenericType);')
        self.cxx.out('std::string asString() throw() { return "%s"; }' % node.corbacxxscoped)
        self.cxx.out('int32_t maxIndex() throw() { return %d; }' % (len(node.enumerators()) - 1))
        self.cxx.out('std::string indexToName(int32_t aIndex) throw(std::exception&)')
        self.cxx.out('{')
        self.cxx.inc_indent()
        self.cxx.out('std::map<uint32_t, std::string>::iterator i = mIntToName.find(aIndex);')
        self.cxx.out('if (i == mIntToName.end()) throw iface::CGRS::CGRSError();')
        self.cxx.out('return (*i).second;')
        self.cxx.dec_indent()
        self.cxx.out('}')

        self.cxx.out('int32_t nameToIndex(const std::string& aName) throw(std::exception&)')
        self.cxx.out('{')
        self.cxx.inc_indent()
        self.cxx.out('std::map<std::string, uint32_t>::iterator i = mNameToInt.find(aName);')
        self.cxx.out('if (i == mNameToInt.end()) throw iface::CGRS::CGRSError();')
        self.cxx.out('return (*i).second;')
        self.cxx.dec_indent()
        self.cxx.out('}')

        self.cxx.dec_indent()
        self.cxx.out('private:')
        self.cxx.inc_indent()
        self.cxx.out('std::map<std::string, uint32_t> mNameToInt;')
        self.cxx.out('std::map<uint32_t, std::string> mIntToName;')
        self.cxx.dec_indent()
        self.cxx.out('};')

    def visitException(self, node):
        pass

    def visitOperation(self, op):
        # The following low-level operations serve no useful purpose in
        # reflection (as the generics service provides a safer alternative),
        # so they are blacklisted and cannot be accessed via CGRS.
        blacklist = ["add_ref", "release_ref", "query_interface"]
        if op.simplename in blacklist:
            return
        self.supportedOperations.append(op.simplename)
        self.generateMethod(op.simplename, op.simplename, op.returnType(), map(lambda p: (p.identifier(), p.paramType(),
                                                                                          p.is_in(), p.is_out()), op.parameters()))

    def generateMethod(self, classname, cxxmethodname, retType, params):
        self.cxx.out('class meth%s' % classname)
        self.cxx.out('  : public iface::CGRS::GenericMethod')
        self.cxx.out('{')
        self.cxx.out('public:')
        self.cxx.inc_indent()

        self.cxx.out('CDA_IMPL_REFCOUNT;')
        self.cxx.out('CDA_IMPL_ID;')
        self.cxx.out('CDA_IMPL_QI1(CGRS::GenericMethod);')
        self.cxx.out('std::vector<iface::CGRS::GenericParameter*> parameters() throw()')
        self.cxx.out('{')
        self.cxx.inc_indent()
        self.cxx.out('std::vector<iface::CGRS::GenericParameter*> params;')

        for (pname, ptype, pIsIn, pIsOut) in params:
            self.cxx.out('params.push_back(new Param%s());' % pname)

        self.cxx.out('return params;')
        self.cxx.dec_indent()
        self.cxx.out('}')

        self.cxx.out('already_AddRefd<iface::CGRS::GenericType> returnType() throw()')
        self.cxx.out('{')
        self.cxx.inc_indent()
        self.cxx.out('ObjRef<CDA_GenericsService> cgs = CreateGenericsServiceInternal();')
        self.cxx.out(GetTypeInformation(retType).fetchType())
        self.cxx.dec_indent()
        self.cxx.out('}')

        self.cxx.out('already_AddRefd<iface::CGRS::GenericValue>')
        self.cxx.out('invoke(iface::CGRS::ObjectValue* aInvokeOn, const std::vector<iface::CGRS::GenericValue*>& aInValues,')
        self.cxx.out('       std::vector<iface::CGRS::GenericValue*>& aOutValues, bool* aWasException)')
        self.cxx.out('  throw(std::exception&)')
        self.cxx.out('{')
        self.cxx.inc_indent()
        self.cxx.out('ObjRef<CDA_GenericsService> cgs = CreateGenericsServiceInternal();')
        self.cxx.out('if (aInvokeOn == NULL) throw iface::CGRS::CGRSError();')
        self.cxx.out('ObjRef<iface::XPCOM::IObject> obj = aInvokeOn->asObject();')
        self.cxx.out('DECLARE_QUERY_INTERFACE_OBJREF(obji, obj, %s);' % self.iface)
        self.cxx.out('if (obji == NULL) throw iface::CGRS::CGRSError();')

        incnt = 0
        for (pname, ptype, pIsIn, pIsOut) in params:
            if pIsIn:
                incnt = incnt + 1
        self.cxx.out('if (aInValues.size() != %d) throw iface::CGRS::CGRSError();' % incnt)

        inidx = 0
        pidx = 0
        paramstring = ''
        for (pname, ptype, pIsIn, pIsOut) in params:
            ti = GetTypeInformation(ptype)
            self.cxx.out(ti.makeStorage('param%d' % pidx))
            self.cxx.out(ti.makeScopedDestructor('param%d' % pidx))
            if pIsIn:
                self.cxx.out('DECLARE_QUERY_INTERFACE_OBJREF(inValues%d, (aInValues[%d]), %s);' % (inidx, inidx, ti.genericIface))
                self.cxx.out(ti.convertGenericToNative('inValues%d' % inidx, 'param%d' % pidx))
                inidx = inidx + 1
            if pidx != 0:
                paramstring = paramstring + ', '
            paramstring = paramstring + '%sparam%d' % (ti.ref(pIsOut), pidx)
            pidx = pidx + 1

        rti = GetTypeInformation(retType)
        self.cxx.out(rti.makeStorage('retval'))
        self.cxx.out(rti.makeScopedDestructor('retval'))
        self.cxx.out('*aWasException = false;')
        self.cxx.out('try')
        self.cxx.out('{')
        self.cxx.inc_indent()
        if rti.typename == 'void':
            retAssign = ''
        else:
            retAssign = 'retval = '
        self.cxx.out('%sobji->%s(%s);' % (retAssign, cxxmethodname, paramstring))
        self.cxx.dec_indent()
        self.cxx.out('}')
        self.cxx.out('catch (...)')
        self.cxx.out('{')
        self.cxx.inc_indent()
        self.cxx.out(rti.defaultStorageValue('retval'))
        pidx = 0
        for (pname, ptype, pIsIn, pIsOut) in params:
            if pIsOut:
                self.cxx.out(rti.defaultStorageValue('param%d' % pidx))
            pidx = pidx + 1
        self.cxx.out('*aWasException = true;')
        self.cxx.dec_indent()
        self.cxx.out('}')

        pidx = 0
        for (pname, ptype, pIsIn, pIsOut) in params:
            ti = GetTypeInformation(ptype)
            if pIsOut:
                self.cxx.out('{')
                self.cxx.inc_indent()
                self.cxx.out('iface::CGRS::GenericValue* gval;')
                self.cxx.out(ti.convertNativeToGeneric('param%d' % pidx, 'gval'))
                self.cxx.out('aOutValues.push_back(gval);')
                self.cxx.dec_indent()
                self.cxx.out('}')
            pidx = pidx + 1

        if rti.typename != 'void':
            self.cxx.out('ObjRef<iface::%s> gretval;' % rti.genericIface)
            self.cxx.out(rti.convertNativeToGeneric('retval', 'gretval'))
            self.cxx.out('gretval->add_ref();')
            self.cxx.out('return gretval.getPointer();')
        else:
            self.cxx.out('return cgs->makeVoid();')

        self.cxx.dec_indent()
        self.cxx.out('}')

        self.cxx.dec_indent()
        self.cxx.out('private:')
        self.cxx.inc_indent()

        for (pname, ptype, pIsIn, pIsOut) in params:
            self.cxx.out('class Param%s' % pname)
            self.cxx.out('  : public iface::CGRS::GenericParameter')
            self.cxx.out('{')
            self.cxx.out('public:')
            self.cxx.inc_indent()
            self.cxx.out('CDA_IMPL_ID;')
            self.cxx.out('CDA_IMPL_REFCOUNT;')
            self.cxx.out('CDA_IMPL_QI1(CGRS::GenericParameter);')
            self.cxx.out('bool isIn() throw() { return ' + ternary(pIsIn, lambda: "true", lambda: "false") + "; }")
            self.cxx.out('bool isOut() throw() { return ' + ternary(pIsOut, lambda: "true", lambda: "false") + "; }")
            self.cxx.out('std::string name() throw() { return "%s"; }' % pname)
            self.cxx.out('already_AddRefd<iface::CGRS::GenericType> type() throw()')
            self.cxx.out('{')
            self.cxx.inc_indent()
            self.cxx.out('ObjRef<CDA_GenericsService> cgs = CreateGenericsServiceInternal();')
            self.cxx.out(GetTypeInformation(ptype).fetchType())
            self.cxx.dec_indent()
            self.cxx.out('}')
            self.cxx.dec_indent()
            self.cxx.out('};')
        self.cxx.dec_indent()
        self.cxx.out('};')

    def visitAttribute(self, at):
        for n in at.declarators():
            self.supportedAttributes.append(n.simplename)
            self.generateMethod('get%s' % n.simplename, n.simplename, at.attrType(), [])
            if not at.readonly():
                self.generateMethod('set%s' % n.simplename, n.simplename, None, [("value", at.attrType(), 1, 0)])

            self.cxx.out('class attr%s' % n.simplename)
            self.cxx.out('  : public iface::CGRS::GenericAttribute')
            self.cxx.out('{')
            self.cxx.out('public:')
            self.cxx.inc_indent()
            self.cxx.out('CDA_IMPL_REFCOUNT;')
            self.cxx.out('CDA_IMPL_ID;')
            self.cxx.out('CDA_IMPL_QI1(CGRS::GenericAttribute);')
            self.cxx.out('bool isReadonly() throw() { return %s; }' % ternary(at.readonly(), lambda: "true", lambda: "false"))
            self.cxx.out('std::string name() throw() { return "%s"; }' % n.simplename)
            self.cxx.out('already_AddRefd<iface::CGRS::GenericType> type() throw()')
            self.cxx.out('{')
            self.cxx.inc_indent()
            self.cxx.out('ObjRef<CDA_GenericsService> cgs = CreateGenericsServiceInternal();')
            self.cxx.out(GetTypeInformation(at.attrType()).fetchType())
            self.cxx.dec_indent()
            self.cxx.out('}')
            self.cxx.out('already_AddRefd<iface::CGRS::GenericMethod> getter() throw() { return new methget%s(); }' % n.simplename)
            if at.readonly():
                self.cxx.out('already_AddRefd<iface::CGRS::GenericMethod> setter() throw(std::exception&) { throw iface::CGRS::CGRSError(); }')
            else:
                self.cxx.out('already_AddRefd<iface::CGRS::GenericMethod> setter() throw() { return new methset%s(); }' % n.simplename)
            self.cxx.dec_indent()
            self.cxx.out('};')
